<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Live Graph</title>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <style>
    body { margin: 0; font-family: Arial, sans-serif; background-color: #000; color: #0f0; }
    .node { stroke: #fff; stroke-width: 1.5px; }
    .link { stroke-width: 2; }
    .tooltip {
      position: absolute; background: #111; border: 1px solid #0f0;
      padding: 6px; font-size: 12px; pointer-events: none; color: #0f0;
    }
    .labels text { paint-order: stroke; stroke: black; stroke-width: 2px; fill: #0f0; }
    .glow { filter: url(#glow); }
    #loader {
      position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
      background-color: #000; display: flex; flex-direction: column;
      align-items: center; justify-content: center; z-index: 1000;
      transition: opacity 0.8s ease;
    }
    #loader.hidden { opacity: 0; pointer-events: none; }
    .spinner {
      width: 50px; height: 50px; border: 5px solid #0f0;
      border-top: 5px solid transparent; border-radius: 50%;
      animation: spin 1s linear infinite; margin-bottom: 16px;
    }
    .loader-text { color: #0f0; font-size: 20px; font-family: monospace; text-shadow: 0 0 10px #0f0; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
  </style>
</head>
<body>
<div id="loader">
  <div class="spinner"></div>
  <div class="loader-text">Loading graph...</div>
</div>
<svg id="graph" style="width: 100vw; height: 100vh;">
  <defs>
    <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
      <feGaussianBlur stdDeviation="2.5" result="coloredBlur"/>
      <feMerge>
        <feMergeNode in="coloredBlur"/>
        <feMergeNode in="SourceGraphic"/>
      </feMerge>
    </filter>
  </defs>
</svg>
<div id="tooltip" class="tooltip" style="display: none;"></div>

<script>
let nodeMap = new Map();

function getNodeColor(node) {
  const status = node.properties?.alarm_status;
  if (status === "RED") return "#ff0000";
  if (status === "YELLOW") return "#ffbf00";
  return "#0f0";
}

function updateGraphProperties(newData) {
  newData.nodes.forEach(n => {
    const existing = nodeMap.get(n.id);
    if (existing) existing.properties = n.properties;
  });

  d3.selectAll("line").each(function(d) {
    const sourceId = typeof d.source === "object" ? d.source.id : d.source;
    const targetId = typeof d.target === "object" ? d.target.id : d.target;

    const updatedLink = newData.links.find(
      l => (l.source === sourceId && l.target === targetId) || (l.source === targetId && l.target === sourceId)
    );

    if (updatedLink) {
      d.properties = updatedLink.properties;
    }
  });

  d3.selectAll("circle").transition().duration(300)
    .attr("fill", getNodeColor);

  d3.selectAll("line").transition().duration(300)
    .style("stroke", d => {
      const s = d.source?.properties?.alarm_status;
      const t = d.target?.properties?.alarm_status;
      if (s === "RED" || t === "RED") return "#ff0000";
      if (s === "YELLOW" || t === "YELLOW") return "#ffbf00";
      return "#0f0";
    });
}

setInterval(() => {
  const ts = Date.now();
  d3.json(`graph-data/graph_live.json?t=${ts}`).then(newData => {
    if (!newData?.nodes?.length) return;
    updateGraphProperties(newData);
  });
}, 5000);

d3.json("graph-data/graph_live.json").then(data => {
  const loader = document.getElementById("loader");
  loader.classList.add("hidden");
  setTimeout(() => loader.remove(), 1000);

  const nodes = data.nodes;
  const links = data.links;
  const svg = d3.select("svg");
  const width = window.innerWidth;
  const height = window.innerHeight;
  const tooltip = d3.select("#tooltip");
  const container = svg.append("g");
  const zoom = d3.zoom().scaleExtent([0.1, 4]).on("zoom", event => container.attr("transform", event.transform));
  svg.call(zoom);

  const link = container.append("g").attr("class", "links")
    .selectAll("line").data(links).enter().append("line")
    .attr("class", "link")
    .style("stroke", d => {
      const statusA = d.source.properties?.alarm_status;
      const statusB = d.target.properties?.alarm_status;
      if (statusA === "RED" || statusB === "RED") return "#ff0000";
      if (statusA === "YELLOW" || statusB === "YELLOW") return "#ffbf00";
      return "#0f0";
    })
    .style("stroke-width", 2)
    .on("mouseover", (event, d) => {
      const latency = d.properties?.latency_ms ? d.properties.latency_ms + "ms" : "N/A";
      const bandwidth = d.properties?.bandwidth_mbps || "N/A";
      const sourceId = d.source.id || d.source;
      const targetId = d.target.id || d.target;
      tooltip.style("display", "block")
        .style("left", (event.pageX + 10) + "px")
        .style("top", (event.pageY + 10) + "px")
        .html(`<strong>Connection</strong><br>From: ${sourceId}<br>To: ${targetId}<br>Latency: ${latency}<br>Bandwidth: ${bandwidth}`);
    })
    .on("mouseout", () => tooltip.style("display", "none"));

  const node = container.append("g").attr("class", "nodes")
    .selectAll("circle").data(nodes).enter().append("circle")
    .attr("r", 12).attr("fill", getNodeColor).attr("class", "node")
    .call(d3.drag()
      .on("start", event => { if (!event.active) simulation.alphaTarget(0.3).restart(); event.subject.fx = event.subject.x; event.subject.fy = event.subject.y; })
      .on("drag", event => { event.subject.fx = event.x; event.subject.fy = event.y; })
      .on("end", event => { if (!event.active) simulation.alphaTarget(0); event.subject.fx = null; event.subject.fy = null; })
    )
    .on("mouseover", (event, d) => {
      tooltip.style("display", "block")
        .style("left", (event.pageX + 10) + "px")
        .style("top", (event.pageY + 10) + "px")
        .html(`<strong>${d.id}</strong><br>${Object.entries(d.properties).map(([k,v]) => `${k}: ${v}`).join("<br>")}`);
    })
    .on("mouseout", () => tooltip.style("display", "none"));

  const labels = container.append("g").attr("class", "labels")
    .selectAll("text").data(nodes).enter().append("text")
    .attr("dy", -10).attr("text-anchor", "middle")
    .text(d => d.id).style("font-size", "14px").style("font-weight", "bold").style("fill", "#0f0");

  const simulation = d3.forceSimulation(nodes)
    .force("link", d3.forceLink(links).id(d => d.id).distance(120))
    .force("charge", d3.forceManyBody().strength(-300))
    .force("center", d3.forceCenter(width / 2, height / 2))
    .on("tick", () => {
      link.attr("x1", d => d.source.x).attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x).attr("y2", d => d.target.y);
      node.attr("cx", d => d.x).attr("cy", d => d.y);
      labels.attr("x", d => d.x).attr("y", d => d.y);
    });

  nodeMap = new Map(nodes.map(n => [n.id, n]));
});
</script>
</body>
</html>
